#pragma once

#include <algorithm>
#include <array>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <random>
#include <type_traits>
#include <utility>

#ifdef __x86_64__
#include <immintrin.h>
#elif defined(__aarch64__)
#include <arm_neon.h>
#else
#error Feijoa is not supported on this architecture.
#endif

class Feijoa {
#ifdef FEIJOA_TESTS
  public:
#else
  protected:
#endif
    struct Vector {
        inline Vector() = default;

#ifdef __x86_64__
        __m128i vector;

        inline explicit Vector(__m128i vector) : vector(vector) {}
        inline explicit Vector(uint64_t low, uint64_t high) : vector(_mm_set_epi64x(high, low)) {}
        static inline Vector load_unaligned(const Vector *p) {
            return Vector{_mm_loadu_si128(reinterpret_cast<const __m128i *>(p))};
        }

        inline Vector multiply_low(Vector rhs) const {
            return Vector{_mm_clmulepi64_si128(vector, rhs.vector, 0x00)};
        }
        inline Vector multiply_high(Vector rhs) const {
            return Vector{_mm_clmulepi64_si128(vector, rhs.vector, 0x11)};
        }
        inline Vector multiply_low_high(Vector rhs) const {
            return Vector{_mm_clmulepi64_si128(vector, rhs.vector, 0x10)};
        }

        inline Vector operator+(Vector rhs) const {
            return Vector{_mm_xor_si128(vector, rhs.vector)};
        }
        inline Vector operator&(Vector rhs) const {
            return Vector{_mm_and_si128(vector, rhs.vector)};
        }

        inline uint64_t low() const { return _mm_cvtsi128_si64(vector); }
        inline uint64_t high() const { return vector[1]; }

        inline Vector set_low(uint64_t low) const {
            // Compiles to movq + movsd or to pinsrq depending on presence of SSE 4.1.
            __m128i copy = vector;
            copy[0] = low;
            return Vector{copy};
        }

        inline Vector zero_high() const { return Vector{_mm_move_epi64(vector)}; }
#else
        poly64x2_t vector;

        inline explicit Vector(poly64x2_t vector) : vector(vector) {}
        inline explicit Vector(uint64_t low, uint64_t high)
            : vector(vcombine_p64(vcreate_p64(low), vcreate_p64(high))) {}
        static inline Vector load_unaligned(const Vector *p) {
            return Vector{vreinterpretq_p64_s8(vld1q_s8(reinterpret_cast<const int8_t *>(p)))};
        }

        inline Vector multiply_low(Vector rhs) const {
            Vector result;
            asm("pmull %0.1q, %1.1d, %2.1d" : "=w"(result.vector) : "w"(vector), "w"(rhs.vector));
            return result;
        }
        inline Vector multiply_high(Vector rhs) const {
            Vector result;
            asm("pmull2 %0.1q, %1.2d, %2.2d" : "=w"(result.vector) : "w"(vector), "w"(rhs.vector));
            return result;
        }
        inline Vector multiply_low_high(Vector rhs) const {
            return Vector{vdupq_laneq_p64(vector, 0)}.multiply_high(rhs);
        }

        inline Vector operator+(Vector rhs) const { return Vector{vaddq_p64(vector, rhs.vector)}; }
        inline Vector operator&(Vector rhs) const {
            return Vector{vreinterpretq_p64_u64(
                vandq_u64(vreinterpretq_u64_p64(vector), vreinterpretq_u64_p64(rhs.vector)))};
        }

        inline uint64_t low() const { return vgetq_lane_u64(vreinterpretq_u64_p64(vector), 0); }
        inline uint64_t high() const { return vgetq_lane_u64(vreinterpretq_u64_p64(vector), 1); }

        inline Vector set_low(uint64_t low) const { return Vector{vsetq_lane_p64(low, vector, 0)}; }

        inline Vector zero_high() const { return Vector{vsetq_lane_p64(0, vector, 1)}; }
#endif
    };

    static inline bool should_use_pdep() {
#ifdef __x86_64__
        // AMD processors before Zen 3 have inefficient microcoded pdep.
        return __builtin_cpu_supports("bmi2") &&
               !(__builtin_cpu_is("amdfam15h") || __builtin_cpu_is("znver1") ||
                 __builtin_cpu_is("znver2"));
#else
        return false;
#endif
    }

    // Low half stores p(x) + x^64, high half stores x^128 // p(x) + x^64.
    Vector low_p_low_x_128_div_p;
    // Low half stores x^128 mod p(x), high half stores x^192 mod p(x).
    Vector x_128_x_192;
    // Low half stores x^512 mod p(x), high half stores x^576 mod p(x).
    Vector x_512_x_576;

    inline uint64_t init_for_basic_computations(uint64_t coeffs) {
        // We wish to pre-compute x^128 // p(x) for Barrett reduction steps. Unfortunately, we can't
        // use Barrett reduction itself to compute the value, so we have to resort to something
        // dumber. Turns out there is an efficient Hensel lifting-like way to compute it anyway.
        Vector zero_coeffs{0, coeffs};
        // We shall maintain the invariant that at the end of i'th iteration,
        //     deg(p(x) * q(x) + x^128) <= 128 - 2^(i+1).
        // Originally, we choose
        //     q(x) = p(x).
        // Indeed, p^2(x) contains only even powers up to 128, so p^2(x) + x^128 contains powers
        // only up to 126. This means we have effectively completed the 0'th iteration.
        // Note that for ease of implementation, we store q(x) + x^64 instead of q(x) itself.
        auto garbage_q = zero_coeffs;
        for (int i = 1; i < 6; i++) {
            // On the i'th iteration, we compute
            //     q'(x) = (q^2(x) // x^64) * p(x) // x^64.
            // We shall show that
            //     deg(p(x) * q(x) + x^128) <= 128 - 2^(i+1)
            // implies
            //     deg(p(x) * q'(x) + x^128) <= 128 - 2^(i+2).
            // Indeed,
            //     q'(x) = ((q^2(x) + a(x)) / x^64 * p(x) + b(x)) / x^64,
            // where deg a(x), deg b(x) < 64. This implies
            //     p(x) * q'(x) = (p(x) * q(x))^2 / x^128 + c(x)
            // where deg c(x) < 64, i.e.
            //     p(x) * q'(x) = (p(x) * q(x))^2 // x^128.
            // Therefore,
            //     p(x) * q'(x) + x^128 = (p(x) * q(x) + x^128)^2 // x^128,
            // hence
            //     deg(p(x) * q'(x) + x^128) = 2 deg(p(x) * q(x) + x^128) - 128
            //         <= 2 * (128 - 2^(i+1)) - 128 = 128 - 2^(i+2),
            // QED.
            // As for computation,
            //     u(x) = (q(x) + x^64)^2 // x^64 = q^2(x) // x^64 + x^64
            auto garbage_u = garbage_q.multiply_high(garbage_q);
            //     q'(x) + x^64 = u(x) * (p(x) + x^64) // x^64 + u(x) + (p(x) + x^64)
            //         = (u(x) + x^64) * p(x) // x^64 + x^64
            //         = (q^2(x) // x^64) * p(x) // x^64 + x^64.
            garbage_q = garbage_u.multiply_high(zero_coeffs) + (garbage_u + zero_coeffs);
        }
        // After the 5'th iteration,
        //     deg(p(x) * q(x) + x^128) <= 64.
        // This means that either
        //     deg(p(x) * q(x) + x^128) < 64
        //         => q(x) = x^128 // p(x),
        // or
        //     deg(p(x) * q(x) + x^128) = 64
        //         => deg(p(x) * (q(x) + 1) + x^128) < 64
        //         => q(x) + 1 = x^128 // p(x).
        // We determine the correct free coefficient by comparing the coefficient at x^64 of
        // p(x) * q(x) to 1. Computationally,
        //     v(x) = (q(x) + x^64) * (p(x) + x^64) // x^64 + (q(x) + x^64) + (p(x) + x^64)
        //         = q(x) * p(x) // x^64 + x^64,
        // thus the coefficient that determines whether q(x) is to be incremented is the free
        // coefficient of v(x).
        auto garbage_v = garbage_q.multiply_high(zero_coeffs) + (garbage_q + zero_coeffs);
        auto garbage_quotient = garbage_q + (garbage_v & Vector{0, 1});

        low_p_low_x_128_div_p = garbage_quotient.set_low(coeffs);

        // We wish to compute x^128 % p(x). We already know what x^128 // p(x) equals, so compute
        //     x^128 % p(x) = x^128 + x^128 // p(x) * p(x) = (x^128 // p(x) * p(x)) mod x^64
        uint64_t x_128 = garbage_quotient.multiply_high(zero_coeffs).low();

        uint64_t x_192 = reduce(Vector{0, x_128});
        x_128_x_192 = Vector{x_128, x_192};
        return x_128;
    }

    inline void init_for_hashing(uint64_t x_128) {
        auto x_256 = square(x_128, std::false_type{});
        uint64_t x_512 = reduce(square(x_256));
        uint64_t x_576 = reduce(Vector{0, x_512});
        x_512_x_576 = Vector{x_512, x_576};
    }

    // Generates a random irreducible polynomial of degree 64 using the given random bit generator.
    template <typename Generator, typename UsePdep>
    static Feijoa random(Generator &generator, UsePdep use_pdep) {
        bring_fs_into_cache();

        while (true) {
            // guess_irreducible() generates a polynomial that is irreducible with probability ~1/8.
            // This is still a lot. As the irreducability check is intrinsically sequential and does
            // not utilize 100% of CPU resources at any tick, it is reasonable to run several checks
            // in lockstep to fill the pipeline better. 6/3 seem to be the most optimal factors with
            // the current performance of Feijoa::Feijoa and is_quasi_irreducible_parallel,
            // depending on whether BMI2 is available.

            std::array<Feijoa, use_pdep ? 6 : 3> feijoas;
            std::array<uint64_t, feijoas.size()> x_128;
            for (size_t i = 0; i < feijoas.size(); i++) {
                x_128[i] = feijoas[i].init_for_basic_computations(guess_irreducible(generator));
            }
            auto results = is_quasi_irreducible_parallel(feijoas, use_pdep);
            for (size_t i = 0; i < feijoas.size(); i++) {
                auto [quasi_irreducible, payload] = results[i];
                if (quasi_irreducible && feijoas[i].is_really_irreducible(payload)) {
                    feijoas[i].init_for_hashing(x_128[i]);
                    return feijoas[i];
                }
            }
        }
    }

    // A random p(x) is irreducible with probability around 1/64. Testing a polynomial for
    // irreducibility is slow, therefore we wish to generate p(x) in a smarter way to increase this
    // probability. One way to do that is to precompute a product of irreducible polynomials of
    // small degree g(x) and only generate p(x) coprime to g(x). We choose
    //     g(x) = x * (x+1) * (x^2+x+1) * (x^3+x+1) * (x^3+x^2+1) * (x^4+x+1)
    //         = x^14 + x^13 + x^12 + x^11 + x^8 + x^7 + x^6 + x^5 + x^4 + x
    // and precompute a table containing all polynomials of degree < 14 coprime to g(x). We can then
    // generate a random p(x) of degree 64 that is necessarily coprime to g(x) by computing
    //     p(x) = g(x) * r(x) + f(x)
    // for a random r(x) of degree 50 and f(x) from the table. Such an optimization increases the
    // probability of irreducibility approximately eightfold (as compared to just fourfold for
    // g(x) = x * (x+1), which does not require a table).
    static constexpr uint16_t FS[]{
        0x1,    0x19,   0x1f,   0x25,   0x29,   0x2f,   0x37,   0x3b,   0x3d,   0x43,   0x49,
        0x57,   0x5b,   0x61,   0x67,   0x6d,   0x73,   0x75,   0x83,   0x89,   0x8f,   0x91,
        0x9d,   0xa7,   0xab,   0xb9,   0xbf,   0xc1,   0xcb,   0xd3,   0xd5,   0xe5,   0xef,
        0xf1,   0xf7,   0xfd,   0x117,  0x11b,  0x11d,  0x12b,  0x12d,  0x139,  0x13f,  0x141,
        0x14d,  0x155,  0x15f,  0x163,  0x165,  0x169,  0x171,  0x177,  0x17b,  0x187,  0x18b,
        0x18d,  0x19f,  0x1a3,  0x1a9,  0x1b1,  0x1bd,  0x1c3,  0x1cf,  0x1d7,  0x1dd,  0x1e7,
        0x1f3,  0x1f5,  0x1f9,  0x203,  0x205,  0x211,  0x217,  0x21b,  0x221,  0x22d,  0x233,
        0x24b,  0x24d,  0x253,  0x259,  0x25f,  0x265,  0x269,  0x26f,  0x277,  0x27d,  0x287,
        0x28b,  0x295,  0x299,  0x2a3,  0x2a5,  0x2af,  0x2b7,  0x2bd,  0x2c9,  0x2cf,  0x2d1,
        0x2db,  0x2f5,  0x2f9,  0x2ff,  0x301,  0x307,  0x313,  0x315,  0x31f,  0x323,  0x331,
        0x33b,  0x345,  0x349,  0x34f,  0x35b,  0x35d,  0x361,  0x36b,  0x36d,  0x373,  0x37f,
        0x383,  0x385,  0x38f,  0x3a1,  0x3a7,  0x3b5,  0x3b9,  0x3c7,  0x3cb,  0x3cd,  0x3d5,
        0x3d9,  0x3e3,  0x3e9,  0x3f1,  0x3fb,  0x409,  0x40f,  0x411,  0x41b,  0x41d,  0x427,
        0x42d,  0x435,  0x43f,  0x441,  0x447,  0x453,  0x455,  0x463,  0x465,  0x46f,  0x471,
        0x47d,  0x481,  0x48b,  0x48d,  0x499,  0x4a9,  0x4af,  0x4b7,  0x4bb,  0x4c3,  0x4c5,
        0x4c9,  0x4d7,  0x4db,  0x4e7,  0x4ed,  0x4f3,  0x4ff,  0x50b,  0x50d,  0x515,  0x519,
        0x51f,  0x523,  0x52f,  0x531,  0x53d,  0x543,  0x545,  0x551,  0x557,  0x561,  0x567,
        0x56b,  0x573,  0x579,  0x585,  0x58f,  0x597,  0x59b,  0x5a1,  0x5ab,  0x5ad,  0x5b3,
        0x5b9,  0x5c1,  0x5c7,  0x5d5,  0x5df,  0x5e5,  0x5f1,  0x5f7,  0x5fb,  0x60b,  0x613,
        0x615,  0x619,  0x623,  0x625,  0x631,  0x637,  0x643,  0x64f,  0x651,  0x65b,  0x66b,
        0x66d,  0x675,  0x679,  0x67f,  0x683,  0x685,  0x689,  0x691,  0x6a7,  0x6ad,  0x6b5,
        0x6bf,  0x6c1,  0x6cd,  0x6d3,  0x6df,  0x6e9,  0x6f7,  0x6fb,  0x6fd,  0x70f,  0x711,
        0x717,  0x71d,  0x721,  0x727,  0x72b,  0x733,  0x735,  0x739,  0x747,  0x74d,  0x755,
        0x759,  0x763,  0x769,  0x76f,  0x77b,  0x77d,  0x781,  0x787,  0x78d,  0x793,  0x79f,
        0x7a9,  0x7b1,  0x7b7,  0x7c5,  0x7db,  0x7dd,  0x7e1,  0x7eb,  0x7f3,  0x7f9,  0x7ff,
        0x805,  0x809,  0x80f,  0x817,  0x82b,  0x82d,  0x839,  0x83f,  0x847,  0x84d,  0x853,
        0x85f,  0x863,  0x865,  0x869,  0x871,  0x87b,  0x88d,  0x895,  0x899,  0x89f,  0x8a9,
        0x8af,  0x8b1,  0x8bb,  0x8c3,  0x8c5,  0x8cf,  0x8d1,  0x8dd,  0x8e1,  0x8e7,  0x8eb,
        0x8f5,  0x901,  0x90d,  0x913,  0x925,  0x929,  0x92f,  0x937,  0x93b,  0x93d,  0x945,
        0x949,  0x951,  0x95b,  0x967,  0x973,  0x975,  0x97f,  0x983,  0x98f,  0x991,  0x99b,
        0x99d,  0x9ab,  0x9ad,  0x9b9,  0x9c1,  0x9c7,  0x9d3,  0x9d9,  0x9e3,  0x9e5,  0x9ef,
        0x9f7,  0x9fd,  0xa01,  0xa07,  0xa0d,  0xa13,  0xa15,  0xa23,  0xa29,  0xa3b,  0xa49,
        0xa4f,  0xa57,  0xa5d,  0xa61,  0xa6d,  0xa73,  0xa79,  0xa7f,  0xa85,  0xa91,  0xa97,
        0xa9d,  0xaa7,  0xaab,  0xab3,  0xab5,  0xac7,  0xacb,  0xad5,  0xad9,  0xadf,  0xae3,
        0xae9,  0xaef,  0xaf1,  0xafb,  0xb03,  0xb05,  0xb09,  0xb11,  0xb17,  0xb21,  0xb2d,
        0xb33,  0xb3f,  0xb41,  0xb4b,  0xb59,  0xb5f,  0xb65,  0xb6f,  0xb77,  0xb7b,  0xb7d,
        0xb87,  0xb8b,  0xb93,  0xb95,  0xba5,  0xbaf,  0xbb1,  0xbb7,  0xbbd,  0xbc3,  0xbc9,
        0xbdb,  0xbdd,  0xbe7,  0xbeb,  0xbed,  0xbf9,  0xc07,  0xc0b,  0xc0d,  0xc19,  0xc1f,
        0xc23,  0xc31,  0xc3d,  0xc43,  0xc4f,  0xc51,  0xc57,  0xc61,  0xc6b,  0xc73,  0xc75,
        0xc79,  0xc85,  0xc89,  0xc97,  0xc9b,  0xc9d,  0xca1,  0xcab,  0xcb3,  0xcb9,  0xcbf,
        0xcc7,  0xccd,  0xcd3,  0xcd5,  0xce3,  0xce5,  0xce9,  0xcf7,  0xd03,  0xd09,  0xd0f,
        0xd1b,  0xd1d,  0xd27,  0xd2d,  0xd35,  0xd3f,  0xd41,  0xd47,  0xd55,  0xd59,  0xd63,
        0xd6f,  0xd71,  0xd77,  0xd7d,  0xd8b,  0xd93,  0xd99,  0xd9f,  0xda5,  0xda9,  0xdbb,
        0xdbd,  0xdc5,  0xdc9,  0xdd1,  0xdd7,  0xddb,  0xde1,  0xde7,  0xdf5,  0xdff,  0xe05,
        0xe0f,  0xe1d,  0xe21,  0xe27,  0xe2b,  0xe33,  0xe35,  0xe39,  0xe47,  0xe4b,  0xe55,
        0xe5f,  0xe6f,  0xe71,  0xe7b,  0xe7d,  0xe81,  0xe8d,  0xe93,  0xe95,  0xe9f,  0xea3,
        0xea5,  0xeb7,  0xebb,  0xec9,  0xecf,  0xedd,  0xee1,  0xeeb,  0xeed,  0xef3,  0xef9,
        0xf01,  0xf07,  0xf0b,  0xf19,  0xf23,  0xf25,  0xf31,  0xf37,  0xf43,  0xf49,  0xf51,
        0xf5d,  0xf67,  0xf6b,  0xf6d,  0xf75,  0xf79,  0xf83,  0xf91,  0xf97,  0xf9b,  0xfa1,
        0xfa7,  0xfad,  0xfb5,  0xfbf,  0xfcb,  0xfcd,  0xfd3,  0xfdf,  0xfe5,  0xfe9,  0xfef,
        0xffb,  0x1005, 0x1009, 0x1017, 0x101b, 0x1021, 0x1027, 0x1033, 0x1035, 0x103f, 0x1041,
        0x104b, 0x104d, 0x1053, 0x1059, 0x1069, 0x106f, 0x1077, 0x107b, 0x107d, 0x1081, 0x1087,
        0x108b, 0x1093, 0x1099, 0x10a3, 0x10a5, 0x10af, 0x10bd, 0x10cf, 0x10d1, 0x10dd, 0x10eb,
        0x10ed, 0x10f5, 0x10ff, 0x1107, 0x110d, 0x1115, 0x111f, 0x1123, 0x1125, 0x1131, 0x1137,
        0x113b, 0x1145, 0x1149, 0x114f, 0x1157, 0x115b, 0x1161, 0x116b, 0x116d, 0x1179, 0x117f,
        0x1183, 0x1185, 0x1191, 0x119d, 0x11a1, 0x11ab, 0x11b3, 0x11c7, 0x11d5, 0x11d9, 0x11df,
        0x11e3, 0x11e9, 0x11ef, 0x11f1, 0x11fd, 0x1201, 0x120b, 0x120d, 0x1213, 0x1219, 0x121f,
        0x1225, 0x1237, 0x123b, 0x123d, 0x1243, 0x1245, 0x1251, 0x1257, 0x1267, 0x126d, 0x1273,
        0x127f, 0x1283, 0x128f, 0x129b, 0x12a7, 0x12ab, 0x12ad, 0x12b5, 0x12b9, 0x12c1, 0x12cb,
        0x12d3, 0x12d5, 0x12d9, 0x12e5, 0x12ef, 0x12f1, 0x1309, 0x130f, 0x131b, 0x131d, 0x1321,
        0x1333, 0x1339, 0x133f, 0x1341, 0x1347, 0x134d, 0x1353, 0x1355, 0x1365, 0x1369, 0x1371,
        0x137b, 0x1387, 0x138d, 0x1395, 0x1399, 0x139f, 0x13a3, 0x13a9, 0x13af, 0x13bb, 0x13c3,
        0x13d1, 0x13d7, 0x13dd, 0x13e7, 0x13eb, 0x13f3, 0x13f5, 0x13f9, 0x1401, 0x1407, 0x1413,
        0x1415, 0x142f, 0x1431, 0x1437, 0x1443, 0x1449, 0x144f, 0x1451, 0x145b, 0x145d, 0x1467,
        0x146b, 0x1475, 0x147f, 0x1489, 0x1491, 0x1497, 0x149b, 0x14a1, 0x14a7, 0x14ad, 0x14b5,
        0x14cd, 0x14d3, 0x14d9, 0x14df, 0x14e5, 0x14f7, 0x14fb, 0x14fd, 0x1503, 0x1505, 0x150f,
        0x1511, 0x1517, 0x151d, 0x1533, 0x1535, 0x1539, 0x1547, 0x154b, 0x154d, 0x1559, 0x155f,
        0x1563, 0x1569, 0x1571, 0x157d, 0x1581, 0x158d, 0x1593, 0x15a3, 0x15a5, 0x15a9, 0x15b7,
        0x15bb, 0x15c5, 0x15cf, 0x15d7, 0x15db, 0x15dd, 0x15e1, 0x15eb, 0x15f9, 0x1603, 0x1609,
        0x161b, 0x162b, 0x162d, 0x1635, 0x1639, 0x163f, 0x1641, 0x1647, 0x164b, 0x1655, 0x1659,
        0x1663, 0x1665, 0x166f, 0x1671, 0x1677, 0x168b, 0x168d, 0x1693, 0x169f, 0x16a5, 0x16a9,
        0x16bd, 0x16c3, 0x16c9, 0x16d1, 0x16d7, 0x16db, 0x16e1, 0x16e7, 0x16ed, 0x16f3, 0x16ff,
        0x170b, 0x1715, 0x1719, 0x1729, 0x172f, 0x1731, 0x173b, 0x173d, 0x1743, 0x1745, 0x174f,
        0x1757, 0x175d, 0x1761, 0x1767, 0x1773, 0x1775, 0x1779, 0x1785, 0x1789, 0x178f, 0x1797,
        0x179d, 0x17a1, 0x17ab, 0x17ad, 0x17b3, 0x17bf, 0x17c1, 0x17d5, 0x17df, 0x17e3, 0x17e5,
        0x17f1, 0x17fb, 0x1807, 0x180d, 0x1815, 0x181f, 0x1823, 0x1825, 0x1829, 0x1831, 0x1837,
        0x1845, 0x1849, 0x1857, 0x185b, 0x185d, 0x186d, 0x1873, 0x1879, 0x187f, 0x1883, 0x188f,
        0x1891, 0x1897, 0x18a1, 0x18b3, 0x18b5, 0x18b9, 0x18c7, 0x18cb, 0x18cd, 0x18df, 0x18e3,
        0x18ef, 0x18f1, 0x18fb, 0x18fd, 0x1905, 0x1909, 0x191b, 0x1921, 0x1927, 0x192d, 0x1933,
        0x1935, 0x1941, 0x194b, 0x1953, 0x1959, 0x195f, 0x1965, 0x1969, 0x196f, 0x197b, 0x1981,
        0x198b, 0x1993, 0x1995, 0x1999, 0x19a3, 0x19af, 0x19b1, 0x19b7, 0x19bd, 0x19c9, 0x19cf,
        0x19dd, 0x19e7, 0x19ed, 0x19f9, 0x19ff, 0x1a09, 0x1a0f, 0x1a1b, 0x1a1d, 0x1a21, 0x1a2b,
        0x1a33, 0x1a41, 0x1a4d, 0x1a53, 0x1a55, 0x1a5f, 0x1a63, 0x1a69, 0x1a77, 0x1a7b, 0x1a87,
        0x1a8b, 0x1a8d, 0x1a95, 0x1a9f, 0x1aa9, 0x1ab1, 0x1abb, 0x1abd, 0x1ac3, 0x1ac5, 0x1acf,
        0x1ad1, 0x1ae1, 0x1ae7, 0x1aeb, 0x1af5, 0x1b01, 0x1b0b, 0x1b0d, 0x1b13, 0x1b19, 0x1b1f,
        0x1b25, 0x1b29, 0x1b2f, 0x1b37, 0x1b43, 0x1b45, 0x1b57, 0x1b5b, 0x1b61, 0x1b6d, 0x1b75,
        0x1b7f, 0x1b89, 0x1b8f, 0x1b91, 0x1b9d, 0x1ba7, 0x1bab, 0x1bb5, 0x1bb9, 0x1bbf, 0x1bc1,
        0x1bc7, 0x1bcb, 0x1bd3, 0x1bd9, 0x1be3, 0x1be5, 0x1bf7, 0x1bfd, 0x1c03, 0x1c05, 0x1c0f,
        0x1c11, 0x1c17, 0x1c1d, 0x1c21, 0x1c27, 0x1c2b, 0x1c39, 0x1c4b, 0x1c4d, 0x1c55, 0x1c5f,
        0x1c63, 0x1c6f, 0x1c71, 0x1c7b, 0x1c81, 0x1c87, 0x1c93, 0x1c9f, 0x1ca5, 0x1ca9, 0x1cb1,
        0x1cb7, 0x1cbb, 0x1cc5, 0x1cc9, 0x1ccf, 0x1cd7, 0x1cdd, 0x1ceb, 0x1ced, 0x1cf3, 0x1cf9,
        0x1d01, 0x1d07, 0x1d13, 0x1d15, 0x1d23, 0x1d2f, 0x1d3d, 0x1d43, 0x1d49, 0x1d51, 0x1d5b,
        0x1d5d, 0x1d67, 0x1d6d, 0x1d75, 0x1d79, 0x1d83, 0x1d85, 0x1d89, 0x1d91, 0x1da7, 0x1db3,
        0x1db5, 0x1dbf, 0x1dc1, 0x1dcb, 0x1dcd, 0x1ddf, 0x1de5, 0x1de9, 0x1def, 0x1df7, 0x1dfb,
        0x1e07, 0x1e0b, 0x1e15, 0x1e19, 0x1e23, 0x1e29, 0x1e2f, 0x1e3b, 0x1e3d, 0x1e45, 0x1e4f,
        0x1e51, 0x1e57, 0x1e5d, 0x1e61, 0x1e67, 0x1e6b, 0x1e73, 0x1e85, 0x1e8f, 0x1e97, 0x1e9b,
        0x1e9d, 0x1ead, 0x1eb3, 0x1eb9, 0x1ebf, 0x1ec1, 0x1ec7, 0x1ecd, 0x1ed3, 0x1ee3, 0x1ee9,
        0x1ef1, 0x1ef7, 0x1f03, 0x1f11, 0x1f1b, 0x1f27, 0x1f2b, 0x1f2d, 0x1f39, 0x1f3f, 0x1f47,
        0x1f4b, 0x1f53, 0x1f55, 0x1f59, 0x1f65, 0x1f71, 0x1f77, 0x1f7d, 0x1f81, 0x1f8d, 0x1f99,
        0x1f9f, 0x1faf, 0x1fbb, 0x1fbd, 0x1fc3, 0x1fc5, 0x1fc9, 0x1fd1, 0x1fdb, 0x1fe1, 0x1fed,
        0x1ff3, 0x1ff5, 0x1fff, 0x2003, 0x2009, 0x200f, 0x201b, 0x201d, 0x2027, 0x202d, 0x2035,
        0x2039, 0x2047, 0x2053, 0x2055, 0x2059, 0x2065, 0x206f, 0x2077, 0x207d, 0x2081, 0x208b,
        0x208d, 0x2093, 0x209f, 0x20a5, 0x20af, 0x20b7, 0x20bb, 0x20bd, 0x20c3, 0x20c5, 0x20c9,
        0x20d1, 0x20e1, 0x20e7, 0x20f3, 0x210b, 0x210d, 0x2115, 0x2119, 0x211f, 0x2123, 0x2129,
        0x212f, 0x2131, 0x213b, 0x2143, 0x2145, 0x2151, 0x215d, 0x2167, 0x216b, 0x2175, 0x2179,
        0x2189, 0x218f, 0x2197, 0x219d, 0x21ad, 0x21b3, 0x21b9, 0x21bf, 0x21c1, 0x21c7, 0x21cd,
        0x21d3, 0x21df, 0x21e3, 0x21e5, 0x21f1, 0x21fb, 0x220b, 0x2213, 0x2219, 0x2223, 0x2225,
        0x222f, 0x2231, 0x2237, 0x223d, 0x2243, 0x2251, 0x225b, 0x225d, 0x226b, 0x2279, 0x227f,
        0x2285, 0x2289, 0x2291, 0x2297, 0x229b, 0x22a1, 0x22b3, 0x22b5, 0x22bf, 0x22c1, 0x22cb,
        0x22cd, 0x22d9, 0x22e5, 0x22ef, 0x22f7, 0x22fb, 0x22fd, 0x2305, 0x230f, 0x231d, 0x2321,
        0x2327, 0x232b, 0x2333, 0x2335, 0x2347, 0x2355, 0x2359, 0x235f, 0x2363, 0x2369, 0x236f,
        0x2371, 0x237d, 0x2387, 0x238d, 0x2393, 0x2395, 0x23a3, 0x23a9, 0x23b1, 0x23b7, 0x23bb,
        0x23c9, 0x23cf, 0x23d7, 0x23db, 0x23e1, 0x23ed, 0x23f9, 0x23ff, 0x2401, 0x240b, 0x2413,
        0x241f, 0x2425, 0x2429, 0x242f, 0x243b, 0x243d, 0x2449, 0x2451, 0x2457, 0x245b, 0x2461,
        0x2467, 0x246d, 0x2475, 0x247f, 0x2483, 0x2489, 0x249b, 0x249d, 0x24ad, 0x24b5, 0x24b9,
        0x24bf, 0x24c1, 0x24c7, 0x24cb, 0x24d5, 0x24d9, 0x24e3, 0x24ef, 0x24f1, 0x24f7, 0x2505,
        0x2509, 0x2517, 0x251d, 0x2521, 0x252b, 0x252d, 0x2533, 0x2539, 0x253f, 0x254d, 0x2553,
        0x2555, 0x255f, 0x2563, 0x2571, 0x2577, 0x2587, 0x258b, 0x2595, 0x2599, 0x259f, 0x25af,
        0x25bb, 0x25bd, 0x25c3, 0x25c5, 0x25cf, 0x25d7, 0x25e1, 0x25eb, 0x25f3, 0x25f5, 0x25f9,
        0x2603, 0x2605, 0x2611, 0x2617, 0x261b, 0x2621, 0x2627, 0x262d, 0x263f, 0x264b, 0x264d,
        0x2653, 0x2659, 0x2665, 0x2669, 0x2677, 0x267b, 0x2681, 0x2687, 0x2693, 0x2699, 0x26a3,
        0x26b1, 0x26b7, 0x26bd, 0x26c3, 0x26c9, 0x26cf, 0x26d1, 0x26dd, 0x26e7, 0x26eb, 0x26ed,
        0x26f5, 0x26ff, 0x2701, 0x2707, 0x270d, 0x2713, 0x2715, 0x2725, 0x2729, 0x2737, 0x273b,
        0x274f, 0x2757, 0x275b, 0x275d, 0x2761, 0x276b, 0x2773, 0x2779, 0x2783, 0x2785, 0x278f,
        0x2791, 0x27a1, 0x27ab, 0x27b3, 0x27b5, 0x27b9, 0x27c7, 0x27cb, 0x27cd, 0x27df, 0x27e9,
        0x27ef, 0x27f1, 0x27fd, 0x2807, 0x280b, 0x280d, 0x2819, 0x281f, 0x2823, 0x2829, 0x2831,
        0x283b, 0x283d, 0x2843, 0x2845, 0x2851, 0x2857, 0x2867, 0x286b, 0x2875, 0x2879, 0x2885,
        0x288f, 0x289d, 0x28a1, 0x28ab, 0x28ad, 0x28bf, 0x28c1, 0x28cd, 0x28d3, 0x28d5, 0x28df,
        0x28e3, 0x28e9, 0x28f7, 0x28fb, 0x2909, 0x290f, 0x2911, 0x291b, 0x291d, 0x2927, 0x292b,
        0x2935, 0x2939, 0x293f, 0x2941, 0x2947, 0x294b, 0x2953, 0x2955, 0x2965, 0x296f, 0x2977,
        0x297d, 0x2981, 0x2993, 0x2999, 0x299f, 0x29a5, 0x29a9, 0x29af, 0x29b7, 0x29bd, 0x29c3,
        0x29d1, 0x29d7, 0x29db, 0x29e1, 0x29ed, 0x29f3, 0x29f5, 0x2a03, 0x2a0f, 0x2a17, 0x2a1d,
        0x2a21, 0x2a27, 0x2a33, 0x2a35, 0x2a39, 0x2a47, 0x2a4b, 0x2a4d, 0x2a55, 0x2a69, 0x2a6f,
        0x2a71, 0x2a7b, 0x2a7d, 0x2a81, 0x2a87, 0x2a95, 0x2a9f, 0x2aa3, 0x2aa5, 0x2aa9, 0x2ab1,
        0x2abb, 0x2ac5, 0x2ac9, 0x2ad7, 0x2adb, 0x2aeb, 0x2aed, 0x2af3, 0x2aff, 0x2b01, 0x2b0b,
        0x2b15, 0x2b19, 0x2b23, 0x2b25, 0x2b2f, 0x2b31, 0x2b37, 0x2b3d, 0x2b43, 0x2b49, 0x2b4f,
        0x2b51, 0x2b6b, 0x2b6d, 0x2b79, 0x2b7f, 0x2b83, 0x2b85, 0x2b89, 0x2b97, 0x2b9b, 0x2ba7,
        0x2bad, 0x2bb3, 0x2bd3, 0x2bd9, 0x2bdf, 0x2be5, 0x2be9, 0x2bef, 0x2bf7, 0x2bfd, 0x2c05,
        0x2c0f, 0x2c1b, 0x2c21, 0x2c2b, 0x2c2d, 0x2c33, 0x2c39, 0x2c3f, 0x2c41, 0x2c47, 0x2c4d,
        0x2c5f, 0x2c63, 0x2c65, 0x2c71, 0x2c77, 0x2c87, 0x2c8b, 0x2c8d, 0x2c95, 0x2c99, 0x2ca3,
        0x2caf, 0x2cbd, 0x2cc5, 0x2cd1, 0x2cd7, 0x2cdd, 0x2ce1, 0x2ce7, 0x2ceb, 0x2cf3, 0x2cf9,
        0x2d0d, 0x2d13, 0x2d19, 0x2d29, 0x2d2f, 0x2d37, 0x2d3b, 0x2d3d, 0x2d43, 0x2d45, 0x2d49,
        0x2d5b, 0x2d61, 0x2d67, 0x2d6d, 0x2d73, 0x2d75, 0x2d7f, 0x2d89, 0x2d8f, 0x2d91, 0x2d9b,
        0x2da7, 0x2dab, 0x2dad, 0x2db5, 0x2dc7, 0x2dcb, 0x2dd3, 0x2dd9, 0x2de3, 0x2de5, 0x2df1,
        0x2dfd, 0x2e01, 0x2e07, 0x2e13, 0x2e15, 0x2e1f, 0x2e25, 0x2e29, 0x2e31, 0x2e37, 0x2e45,
        0x2e49, 0x2e4f, 0x2e5b, 0x2e5d, 0x2e61, 0x2e6b, 0x2e73, 0x2e79, 0x2e83, 0x2e8f, 0x2e91,
        0x2e97, 0x2e9d, 0x2ea1, 0x2ea7, 0x2eab, 0x2eb3, 0x2eb9, 0x2ecd, 0x2ed5, 0x2ed9, 0x2edf,
        0x2ee3, 0x2efb, 0x2efd, 0x2f03, 0x2f05, 0x2f09, 0x2f11, 0x2f17, 0x2f27, 0x2f33, 0x2f35,
        0x2f3f, 0x2f41, 0x2f4b, 0x2f4d, 0x2f59, 0x2f5f, 0x2f65, 0x2f69, 0x2f77, 0x2f7b, 0x2f81,
        0x2f8b, 0x2f95, 0x2fa3, 0x2fa5, 0x2faf, 0x2fb1, 0x2fc3, 0x2fcf, 0x2fd1, 0x2fdb, 0x2fdd,
        0x2fe7, 0x2fed, 0x2ff5, 0x2fff, 0x3001, 0x3007, 0x300b, 0x3013, 0x3015, 0x3019, 0x3023,
        0x302f, 0x303d, 0x3049, 0x304f, 0x305b, 0x3067, 0x3075, 0x3079, 0x307f, 0x3085, 0x3091,
        0x3097, 0x309b, 0x30a1, 0x30ad, 0x30b3, 0x30b5, 0x30bf, 0x30c1, 0x30cb, 0x30d3, 0x30d9,
        0x30df, 0x30e5, 0x30e9, 0x30ef, 0x30fd, 0x3103, 0x3105, 0x310f, 0x3111, 0x3117, 0x312b,
        0x3135, 0x3139, 0x3147, 0x314d, 0x3155, 0x3159, 0x315f, 0x3163, 0x3171, 0x317b, 0x317d,
        0x3187, 0x318d, 0x3193, 0x3195, 0x31a3, 0x31a9, 0x31b1, 0x31b7, 0x31c5, 0x31c9, 0x31db,
        0x31dd, 0x31e1, 0x31eb, 0x31ed, 0x31f3, 0x31ff, 0x3203, 0x3209, 0x320f, 0x3211, 0x321d,
        0x3227, 0x322b, 0x322d, 0x3239, 0x323f, 0x3241, 0x324b, 0x3253, 0x3259, 0x3263, 0x3265,
        0x3277, 0x327d, 0x3281, 0x328b, 0x3293, 0x3299, 0x329f, 0x32a9, 0x32af, 0x32b7, 0x32bb,
        0x32c3, 0x32c5, 0x32d7, 0x32db, 0x32e1, 0x32e7, 0x32ed, 0x32f5, 0x3307, 0x330b, 0x3315,
        0x331f, 0x3329, 0x332f, 0x3331, 0x333b, 0x333d, 0x3343, 0x334f, 0x3351, 0x335d, 0x3361,
        0x3373, 0x3375, 0x3379, 0x3389, 0x3397, 0x339b, 0x339d, 0x33ab, 0x33ad, 0x33b9, 0x33c1,
        0x33c7, 0x33cd, 0x33d5, 0x33df, 0x33e3, 0x33e5, 0x33e9, 0x33f7, 0x33fb, 0x3403, 0x3409,
        0x3411, 0x341b, 0x3421, 0x3427, 0x3433, 0x3435, 0x343f, 0x3441, 0x344d, 0x3453, 0x345f,
        0x3469, 0x3477, 0x347b, 0x347d, 0x3487, 0x3493, 0x3495, 0x3499, 0x34a3, 0x34a5, 0x34b7,
        0x34bd, 0x34c3, 0x34c9, 0x34cf, 0x34db, 0x34e7, 0x34eb, 0x34ed, 0x34f5, 0x34f9, 0x3501,
        0x3507, 0x350d, 0x351f, 0x3523, 0x3525, 0x3529, 0x3531, 0x3537, 0x3545, 0x354f, 0x3557,
        0x355d, 0x356b, 0x356d, 0x3573, 0x357f, 0x3585, 0x358f, 0x3591, 0x3597, 0x359d, 0x35a1,
        0x35a7, 0x35ab, 0x35b5, 0x35b9, 0x35cb, 0x35cd, 0x35d5, 0x35d9, 0x35e3, 0x35e9, 0x35ef,
        0x35fb, 0x3601, 0x360b, 0x360d, 0x3619, 0x361f, 0x3625, 0x362f, 0x3637, 0x363b, 0x3645,
        0x3649, 0x3651, 0x3657, 0x365b, 0x366d, 0x3673, 0x3675, 0x367f, 0x3683, 0x3689, 0x3691,
        0x369b, 0x369d, 0x36a7, 0x36ad, 0x36b9, 0x36bf, 0x36c7, 0x36cb, 0x36d3, 0x36d5, 0x36e3,
        0x36e5, 0x36ef, 0x36f1, 0x3705, 0x3709, 0x370f, 0x3717, 0x371b, 0x371d, 0x3721, 0x372d,
        0x3733, 0x3739, 0x3741, 0x3747, 0x3753, 0x3769, 0x3771, 0x3777, 0x377b, 0x378b, 0x3795,
        0x3799, 0x379f, 0x37a3, 0x37af, 0x37b1, 0x37bb, 0x37bd, 0x37c5, 0x37cf, 0x37d1, 0x37d7,
        0x37dd, 0x37e1, 0x37e7, 0x37f3, 0x3803, 0x3805, 0x3811, 0x3817, 0x381d, 0x3827, 0x382b,
        0x3833, 0x3847, 0x384b, 0x384d, 0x3855, 0x3859, 0x385f, 0x3863, 0x3869, 0x386f, 0x3871,
        0x3881, 0x388d, 0x3895, 0x389f, 0x38a3, 0x38a5, 0x38b1, 0x38bb, 0x38c9, 0x38cf, 0x38d7,
        0x38db, 0x38e1, 0x38f3, 0x38f9, 0x38ff, 0x3901, 0x3907, 0x390b, 0x3913, 0x3915, 0x3919,
        0x3925, 0x3931, 0x393d, 0x3949, 0x394f, 0x395b, 0x395d, 0x3967, 0x396b, 0x396d, 0x3975,
        0x3983, 0x3985, 0x3989, 0x3997, 0x39a1, 0x39a7, 0x39ad, 0x39b3, 0x39bf, 0x39c1, 0x39cb,
        0x39cd, 0x39d3, 0x39d9, 0x39ef, 0x39f7, 0x39fd, 0x3a07, 0x3a0d, 0x3a19, 0x3a1f, 0x3a23,
        0x3a29, 0x3a2f, 0x3a3b, 0x3a3d, 0x3a43, 0x3a4f, 0x3a51, 0x3a5d, 0x3a61, 0x3a67, 0x3a6b,
        0x3a73, 0x3a75, 0x3a85, 0x3a89, 0x3a8f, 0x3a9b, 0x3aa1, 0x3ab9, 0x3abf, 0x3ac7, 0x3acd,
        0x3ad3, 0x3ad5, 0x3adf, 0x3ae5, 0x3ae9, 0x3af1, 0x3af7, 0x3afb, 0x3b0f, 0x3b11, 0x3b1b,
        0x3b1d, 0x3b2b, 0x3b2d, 0x3b35, 0x3b39, 0x3b3f, 0x3b41, 0x3b4b, 0x3b53, 0x3b59, 0x3b63,
        0x3b65, 0x3b6f, 0x3b71, 0x3b77, 0x3b81, 0x3b8b, 0x3b8d, 0x3b93, 0x3b99, 0x3ba5, 0x3ba9,
        0x3bb7, 0x3bbb, 0x3bc5, 0x3bc9, 0x3bd1, 0x3be7, 0x3bf3, 0x3bf5, 0x3bff, 0x3c01, 0x3c0d,
        0x3c13, 0x3c15, 0x3c1f, 0x3c23, 0x3c25, 0x3c31, 0x3c37, 0x3c3b, 0x3c45, 0x3c4f, 0x3c57,
        0x3c5d, 0x3c6b, 0x3c6d, 0x3c79, 0x3c7f, 0x3c83, 0x3c85, 0x3c8f, 0x3c97, 0x3c9d, 0x3ca7,
        0x3cab, 0x3cb3, 0x3cb9, 0x3cc7, 0x3ccb, 0x3cd9, 0x3ce9, 0x3cf1, 0x3cfb, 0x3cfd, 0x3d03,
        0x3d09, 0x3d11, 0x3d17, 0x3d1b, 0x3d21, 0x3d27, 0x3d2d, 0x3d33, 0x3d35, 0x3d41, 0x3d4d,
        0x3d53, 0x3d5f, 0x3d65, 0x3d69, 0x3d6f, 0x3d7b, 0x3d7d, 0x3d81, 0x3d87, 0x3d8b, 0x3d95,
        0x3da5, 0x3daf, 0x3db1, 0x3db7, 0x3dc3, 0x3dd1, 0x3ddb, 0x3ddd, 0x3de7, 0x3deb, 0x3df5,
        0x3df9, 0x3dff, 0x3e05, 0x3e09, 0x3e0f, 0x3e17, 0x3e1b, 0x3e1d, 0x3e21, 0x3e2b, 0x3e33,
        0x3e3f, 0x3e41, 0x3e47, 0x3e53, 0x3e55, 0x3e63, 0x3e65, 0x3e69, 0x3e7b, 0x3e87, 0x3e8b,
        0x3e8d, 0x3ea3, 0x3ea9, 0x3eaf, 0x3eb1, 0x3ebd, 0x3ec3, 0x3ec5, 0x3ecf, 0x3ed7, 0x3edd,
        0x3ee1, 0x3ef5, 0x3ef9, 0x3f0b, 0x3f0d, 0x3f13, 0x3f19, 0x3f1f, 0x3f25, 0x3f29, 0x3f37,
        0x3f3d, 0x3f43, 0x3f45, 0x3f49, 0x3f51, 0x3f57, 0x3f61, 0x3f67, 0x3f6d, 0x3f7f, 0x3f83,
        0x3f89, 0x3f91, 0x3f9b, 0x3fab, 0x3fad, 0x3fb5, 0x3fbf, 0x3fc1, 0x3fc7, 0x3fd5, 0x3fd9,
        0x3fe3, 0x3fef, 0x3ff1, 0x3ff7, 0x3ffd};

    static inline void bring_fs_into_cache() {
        // Attempt to prevent cache timing attacks on the f(x) table.
        constexpr size_t cacheline_size = 64;
        for (size_t i = 0; i < sizeof(FS); i += cacheline_size) {
            reinterpret_cast<const volatile char *>(FS)[i];
        }
    }

    // Takes a good guess at an irreducible polynomial.
    template <typename Generator> static uint64_t guess_irreducible(Generator &generator) {
        std::uniform_int_distribution<size_t> rng_f_index{0, sizeof(FS) / sizeof(FS[0]) - 1};
        uint64_t f = FS[rng_f_index(generator)];

        std::uniform_int_distribution<uint64_t> rng_r{uint64_t{1} << 50, (uint64_t{1} << 51) - 1};
        uint64_t r = rng_r(generator);

        // p(x) = g(x) * r(x) + f(x)
        Vector g_zero{0x79f2, 0};
        uint64_t low_p = Vector{r, 0}.multiply_low(g_zero).low() ^ f;

        return low_p;
    }

    // Given a(x), computes a representative of a(x)^2 (mod p(x)).
    inline Vector square(Vector a) const {
        // In F_2,
        //     ((high << 64) + low)^2 = (high^2 << 128) + low^2.
        return shift_128(a.multiply_high(a)) + a.multiply_low(a);
    }

    // Given a(x), computes a representative of a(x)^2 (mod p(x)).
    template <typename UsePdep> Vector square(uint64_t a, UsePdep use_pdep) const {
        if constexpr (use_pdep) {
#ifdef __x86_64__
            uint64_t high, low;
            asm("pdep %1, %2, %0" : "=r"(high) : "r"(0x5555555555555555), "r"(a >> 32));
            asm("pdep %1, %2, %0" : "=r"(low) : "r"(0x5555555555555555), "r"(a));
            return Vector{low, high};
#else
            __builtin_trap();
#endif
        } else {
            Vector a_vec{a, 0};
            return a_vec.multiply_low(a_vec);
        }
    }

    // Given a(x), computes a representative of a(x) * x^128 (mod p(x)).
    inline Vector shift_128(Vector a) const {
        // In F_2,
        //     ((high << 64) + low) << 128 = (high << 192) + (low << 128),
        // hence
        //     a << 128 = high * ((1 << 192) mod p(x)) + low * ((1 << 128) mod p(x)) (mod p(x)).
        return a.multiply_low(x_128_x_192) + a.multiply_high(x_128_x_192);
    }

    // Given a(x), computes a representative of a(x) * x^512 (mod p(x)).
    inline Vector shift_512(Vector a) const {
        // In F_2,
        //     ((high << 64) + low) << 512 = (high << 576) + (low << 512),
        // hence
        //     a << 512 = high * ((1 << 576) mod p(x)) + low * ((1 << 512) mod p(x)) (mod p(x)).
        return a.multiply_low(x_512_x_576) + a.multiply_high(x_512_x_576);
    }

    // Given a(x), computes a(x) mod p(x).
    inline uint64_t reduce(Vector a) const {
        // a(x) mod p(x) = ((high << 64) + low) mod p(x) = (high << 64) mod p(x) + low.

        // Perform Barrett reduction on (high << 64): we shall compute
        //     q(x) = (high << 64) // p(x)
        // as
        //     q'(x) = high * (x^128 // p(x)) // x^64.
        // Indeed, replacing truncating division with rational division yields
        //     q(x) = ((high << 64) + A(x)) / p(x),
        //     q'(x) = (high * (x^128 + B(x)) / p(x) + C(x)) / x^64,
        // where deg A(x), deg B(x), deg C(x) < 64, and hence
        //     q(x) = (high << 64) / p(x) + A(x) / p(x),
        //     q'(x) = (high << 64) / p(x) + (high * B(x) / p(x) + C(x)) / x^64,
        // which implies
        //     q(x) + q'(x) = A(x) / p(x) + (high * B(x) / p(x) + C(x)) / x^64,
        // which is a ratio of a negative degree but also a polynomial, i.e. 0.
        auto garbage_q = a + a.multiply_high(low_p_low_x_128_div_p);

        // Compute the low 64 bits of
        //     a(x) mod p(x) = a(x) + q(x) * p(x).
        return (a + low_p_low_x_128_div_p.multiply_low_high(garbage_q)).low();
    }

    // p(x) of degree d is irreducible over F_2 iff:
    //     x^(2^d) = x (mod p(x)), and
    //     for all prime m | d: (x^(2^(d/m)) + x, p(x)) = 1.
    // For d = 64, this translates to
    //     x^(2^64) = x (mod p(x)), and
    //     (x^(2^32) + x, p(x)) = 1.
    // The latter check passes with high probability given that the former check passes.

    // Tests if multiple p(x) pass a loose irreducibility check and returns initialization data for
    // a real check.
    template <size_t N, typename UsePdep>
    static std::array<std::pair<bool, uint64_t>, N>
    is_quasi_irreducible_parallel(const std::array<Feijoa, N> &feijoas, UsePdep use_pdep) {
        using element_type = typename std::conditional<use_pdep, uint64_t, Vector>::type;

        element_type x_2_32[N];

        // Compute x^(2^32) via repeated squaring.

        // Initialize with x^(2^7) mod p(x).
        for (size_t i = 0; i < N; i++) {
            if constexpr (use_pdep) {
                x_2_32[i] = feijoas[i].x_128_x_192.low();
            } else {
                x_2_32[i] = feijoas[i].x_128_x_192.zero_high();
            }
        }

        for (int i = 7; i < 32; i++) {
            for (size_t i = 0; i < N; i++) {
                if constexpr (use_pdep) {
                    x_2_32[i] = feijoas[i].reduce(feijoas[i].square(x_2_32[i], use_pdep));
                } else {
                    x_2_32[i] = feijoas[i].square(x_2_32[i]);
                }
            }
        }

        // Compute x^(2^64) as (x^(2^32))^(2^32)).
        element_type x_2_64[N];
        for (size_t i = 0; i < N; i++) {
            x_2_64[i] = x_2_32[i];
        }
        for (int i = 32; i < 64; i++) {
            for (size_t i = 0; i < N; i++) {
                if constexpr (use_pdep) {
                    x_2_64[i] = feijoas[i].reduce(feijoas[i].square(x_2_64[i], use_pdep));
                } else {
                    x_2_64[i] = feijoas[i].square(x_2_64[i]);
                }
            }
        }

        std::array<std::pair<bool, uint64_t>, N> results;
        for (size_t i = 0; i < N; i++) {
            // x^(2^64) = x?
            if constexpr (use_pdep) {
                results[i] = {x_2_64[i] == 2, x_2_32[i]};
            } else {
                bool success = feijoas[i].reduce(x_2_64[i]) == 2;
                results[i] = {success, success ? feijoas[i].reduce(x_2_32[i]) : 0};
            }
        }
        return results;
    }

    // Tests if p(x) is quasi-irreducible.
    template <typename UsePdep>
    std::pair<bool, uint64_t> is_quasi_irreducible(UsePdep use_pdep) const {
        return is_quasi_irreducible_parallel(std::array<Feijoa, 1>{*this}, use_pdep)[0];
    }

    // Tests if p(x) is quasi-irreducible.
    inline std::pair<bool, uint64_t> is_quasi_irreducible() const {
        if (should_use_pdep()) {
            return is_quasi_irreducible(std::true_type{});
        } else {
            return is_quasi_irreducible(std::false_type{});
        }
    }

    // Tests if quasi-irreducible p(x) is irreducible.
    inline bool is_really_irreducible(uint64_t x_2_32) const {
        // We now wish to compute (a(x), p(x)), where a(x) = x^(2^32) + x.
        uint64_t a = x_2_32 ^ 2;
        uint64_t coeffs = get_seed();
        // Perform one iteration of the binary Euclidian algorithm to ensure that the second
        // argument fits in 64 bits.
        if (a == 0 || !(coeffs & 1)) {
            return false;
        }
        a >>= __builtin_ctzl(a);
        // p(x) and a(x) are now both odd, compute b(x) = (p(x) + a(x)) / x.
        uint64_t b = (uint64_t{1} << 63) | ((coeffs ^ a) >> 1);
        // Perform the rest of the binary Euclidian algorithm. The invariant is that at the start of
        // each iteartion, a is odd and b is non-zero.
        while (a != 1) {
            // Make b odd.
            b >>= __builtin_ctzl(b);
            if (a > b) {
                std::swap(a, b);
            }
            b ^= a;
            if (b == 0) {
                // GCD is a(x) != 1.
                return false;
            }
        }
        // GCD is (a(x), b(x)) = (1, b(x)) = 1.
        return true;
    }

    // Tests if p(x) is irreducible.
    template <typename UsePdep> bool is_irreducible(UsePdep use_pdep) const {
        auto results = is_quasi_irreducible_parallel(std::array<Feijoa, 1>{*this}, use_pdep);
        auto [quasi_irreducible, payload] = results[0];
        return quasi_irreducible && is_really_irreducible(payload);
    }

  public:
    inline Feijoa() = default;

    // coeffs represents p(x) = x^64 + coeffs_63 x^63 + ... + coeffs_0.
    inline explicit Feijoa(uint64_t coeffs) {
        init_for_hashing(init_for_basic_computations(coeffs));
    }

    // Generates a random irreducible polynomial of degree 64 using the given random bit generator.
    template <typename Generator> static Feijoa random(Generator &generator) {
        if (should_use_pdep()) {
            return random(generator, std::true_type{});
        } else {
            return random(generator, std::false_type{});
        }
    }

    // Generates several distinct random irreducible polynomials of degree 64 using the given random
    // bit generator.
    template <size_t N, typename Generator>
    static std::array<Feijoa, N> random_many(Generator &generator) {
        std::array<Feijoa, N> feijoas;
        for (auto it = feijoas.begin(); it != feijoas.end(); ++it) {
            do {
                *it = random(generator);
                // In the unlikely case that two polynomials are equal, regenerate. This is a
                // security feature: the probability that two given strings are congruent modulo
                // irreducible polynomials p1(x), ..., pk(x) increases significantly if any of them
                // match.
                //
                // For distinct p1(x), ..., pk(x), though, the collision probability is provably
                // exponential in k. Indeed,
                //     a(x) = 0 (mod pi(x)) for all i
                // holds if p1(x), ..., pk(x) are all present in the factorization of a(x). The
                // worst case is when a(x) is a product of (deg a(x) / 64) distinct irreducible
                // polynomials of degree 64 each. In this case, there are "(deg a(x) / 64) choose k"
                // choices of the set {p1(x), ..., pk(x)} that result in a collision. That's among
                // "2^58 choose k" ways to choose such a set in total. This results in a collision
                // probability of:
                //     ((deg a(x) / 64) choose k) / (2^58 choose k)
                //     ~ ((deg a(x) / 64) choose k) / (2^(58k) / k!)
                //     <= ((deg a(x) / 64)^k / k!) / (2^(58k) / k!)  [actually ~ for large a(x)]
                //     = (deg a(x) / 2^64)^k,
                // which proves that the probability is exponential in k.
                //
                // Keep this quadratic: that should be more efficient in the common case where k is
                // low.
            } while (std::find(feijoas.begin(), it, *it) != it);
        }
        return feijoas;
    }

    // Tests if p(x) is irreducible.
    inline bool is_irreducible() const {
        if (should_use_pdep()) {
            return is_irreducible(std::true_type{});
        } else {
            return is_irreducible(std::false_type{});
        }
    }

    // Returns a seed that can be used to restore the Feijoa instance later.
    inline uint64_t get_seed() const { return low_p_low_x_128_div_p.low(); }

    // Computes the hash of an array whose length is a product of 16.
    inline uint64_t reduce(const char *data, size_t n) const {
        assert(n % 16 == 0);

        // Save for reordering of some bits, this function effectively computes
        //     (a_0 + a_1 x + ... + a_{8n-1} x^{n-1} + x^{8n+64}) mod p(x).
        // Adding x^{8n+64} ensures that P(hash(a(x)) = b(x)) is low for fixed b(x), which is a
        // requirement typically imposed on ideal hashes. Indeed,
        //     a(x) + x^{8n+64} = b(x)  (mod p(x))
        // is equivalent to
        //     p(x) | a(x) + x^{8n+64} + b(x),
        // where the right-hand side is neceessarily non-zero. Omitting x^{8n+64} would break this
        // guarantee if deg a(x) < 64. Using a power lower than 64 would break it for n = 0, which
        // is perhaps not a bad thing, really, but using 64 is free so why not.

        auto casted = reinterpret_cast<const Vector *>(data);

        size_t i = 0;

        Vector acc3{0, 0};
        Vector acc2{0, 0};
        Vector acc1{0, 0};
        Vector acc0{0, 1};
        while (i + 64 <= n) {
            acc3 = shift_512(acc3) + Vector::load_unaligned(casted + i / 16);
            acc2 = shift_512(acc2) + Vector::load_unaligned(casted + i / 16 + 1);
            acc1 = shift_512(acc1) + Vector::load_unaligned(casted + i / 16 + 2);
            acc0 = shift_512(acc0) + Vector::load_unaligned(casted + i / 16 + 3);
            i += 64;
        }
        auto acc = acc3;
        acc = shift_128(acc) + acc2;
        acc = shift_128(acc) + acc1;
        acc = shift_128(acc) + acc0;

        while (i + 16 <= n) {
            acc = shift_128(acc) + Vector::load_unaligned(casted + i / 16);
            i += 16;
        }

        return reduce(acc);
    }

    inline bool operator==(const Feijoa &rhs) const { return get_seed() == rhs.get_seed(); }
    inline bool operator!=(const Feijoa &rhs) const { return !(*this == rhs); }
};
